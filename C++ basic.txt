基础入门：
1.变量：给一段指定的内存空间起名，方便操作。
2.常量：不可更改的数据。
   #define 常量名 常量值
   const int a = 10;
3.数据类型：合理分配内存空间。
4.默认输出小数6位有效数字。
5.字符串型：
   C风格字符串：char[]="  ";
   C++：string a = "   ";

核心编程：
1.内存分区模型：
    代码区（共享，只读）；全局区（全局变量、静态变量、常量（const修饰的局部变量不再常量区））；栈区(局部变量、形参)；堆区（new）。
2.引用：
    合法内存空间。（const int & ref = 10 -> 编译器：int temp = 10; const int & ref = temp）
    必须初始化(与谁绑定)；初始化后不可改变。
    函数返回值是引用可以作为左值。
    本质是 int * const ref。
3.函数提高：
    函数默认值，从左到右必须有默认值。
    函数声明和实现只能一个有默认参数。
    占位参数只有数据类型。
    const int &a和int & a可以重载，func(10)调用const因为const int & a =10合法，int a =10,func(a)调用int & a。
    重载用默认参数容易产生二义性。
4.类和对象
    封装、继承、多态。
    protected:子可以继承。
    protected和private都类内可以访问，类外不可以。
    struct默认为public，class默认为private。
    成员函数可直接调用类内属性，少传入入参。
    类中可以让另一个类作为本类中的成员。
    类的头文件写属性和函数声明，cpp文件中用：：写全函数。
    构造函数：无参和有参 或者 普通和拷贝（Person(const Person& p)）。
    Person(10)匿名对象，当前行执行结束后，系统会立即回收掉匿名对象。
    不要 利用拷贝构造函数初始化匿名对象。（person(p3) === person p3，认为对象声明，重定义）。
    用户定义有参构造函数，系统不默认提供无参构造但提供拷贝构造；用户定义拷贝构造，则默认不提供无参和有参构造。
    浅拷贝析构delete指针时，堆区内存重复释放。
    初始化列表--构造函数():属性1(值1),属性2(值2)...{}。
    其他类对象作为本类成员，先构造其他类对象再构造自身。
    静态成员变量需要类内声明，类外初始化操作--可以通过对象和类名访问。
    静态成员函数只能访问静态成员变量(无法区分到底是哪个对象的属性)。
    空类占用内存为1字节。
    只有非静态成员变量属于类对象，成员变量和成员函数是分开存储的。
    链式编程(返回自身引用，否则调用拷贝构造函数构造临时变量)--cout << a << b。
    this指向当前对象，空指针可以访问对象的函数但是不能访问属性。
    成员函数后加const，修饰的是this指针，指向的值不能修改--常函数，成员属性用mutable在常函数、常对象中可以修改。
    常对象只能调用常函数。
    友元friend可以访问private--友元只需要在类开头(无需public、private,成员函数用：：加上类)加friend作声明。
    类也可以声明--class Building;
    <<重载一般写成全局函数(ostream & cout)，成员函数cout会在右面，与平时使用不同。
    前置递增返回引用，后置递增返回临时值(临时值不能返回引用)--并且入参写int占位，固定模式。
    仿函数就是()重载--使用形式与函数相似。
--重载=深拷贝入参不用引用会出错？
5.继承
    class 子类: 继承方式  父类1，继承方式  父类2(多继承不建议)
    父类private，子类都不可访问。
    protected继承父类中public和protected都变成protected，private同理。
    父类中所有非静态成员属性都会被子类继承(private隐藏了但被继承)。
    继承先构造父类然后子类，析构相反。
    继承同名成员子类中直接用，父类要加作用域(s.Base::AA;s.Base::func())--静态非静态都可以。
    子类出现父类同名的成员函数，子类同名函数会隐藏父类所有同名函数(包括重载)--所以加作用域。
    Son::Base::m_A(通过son类名访问父类作用域)。
    虚继承(virtual)，虚基类--数据只有一份，避免菱形继承两份数据(虚继承表--虚继承指针--一份数据)。
6.多态
    静态多态：函数重载、运算符重载     --地址早绑定(传子类也会运行父类函数)
    动态多态：派生类、虚函数(virtual)   --地址晚绑定
           条件：1.有继承关系  2.子类重写父类的虚函数
           使用：父类的指针或者引用指向子类对象
           存放的是vfptr(虚函数指针),子类继承了vfptr，但是当子类重写了虚函数，子类内部会替换为子类的虚函数地址。
    好处：1.组织结构清晰  2.可读性强  3.对于前期和后期扩展以及维护性高
    纯虚函数： 虚函数 = 0 ；-- 抽象类(特点：无法实例化对象，子类必须重写纯虚函数否则也属于抽象类)
    虚析构和纯虚析构：父类指针在析构时不会调用子类中析构函数 -- 使用虚析构
                                 纯虚析构需要类外实现(有纯虚析构也是抽象类) -- 类名::~类名()
                                 子类中没有堆区数据可以不写
7.文件操作
    #include<fstream> -- ofstream(写)、ifstream(读)、stream(读写)
    ofstream ofs;ofs.open("文件路径",打开方式 | 两种方法);ofs<<"写入数据";ofs.close();

提高编程：
1.模板
    泛型编程
    函数模板和类模板
    template<typename T>   template<class T>
    使用方式:1.自动类型推导 2.显示指定类型(mySwap<int>(a, b))
    模板必须确定出T的数据类型(有入参，或者显示指定类型)
    自动类型推导不能发生普通函数的隐式类型转换，但是显示指定类型可以。
    调用规则：1.函数模板和普通函数都可以实现，优先普通函数。
                    2.可以通过空模板参数列表强制调用函数模板。
                       myPrint<>(a,b);
                    3.函数模板可以重载。
                    4.函数模板可以更好匹配优先调用模板。
    提供函数模板最好不提供普通函数。
    模板局限性(类似T为array[]，直接比较大小)
           1.运算符重载
           2.重载(利用具体化的模板解决自定义类型的通用化): 
                    template<> bool myCompare(Person &p1, Perso &p2)
    template<class T1, class T2>
    类模板没有自动类型推导，在模板参数列表可以有默认参数。
           1.Person<string,int> p("A",1);
           2.template <class T, class T1 = int>
              Person<string> p("A",1);
    普通类中成员函数一开始可以创建，类模板中调用才创建。
    类模板对象做函数参数：
           1.指定传入类型: void printPerson1(Person<string, int>&p)
           2.参数模板化: 
                     template<class T1, class T2>
                     void printPerson2(Person<T1, T2>&p)
           3.整个类模板化:
                     template<class T>
                     void printPerson3(T &p)
    类模板与继承: 父类是类模板，子类声明要指定父类中T的类型(无法分配内存空间)，子类也可以变为类模板
    类模板成员函数类外实现:
           template<class T1,class T2>
           Person<T1, T2>::Person(T1 name, T2 age)
    
    类模板与友元:
